<style>
    /* ================================================== */
    /* REPARIERTE CSS-LOGIK F√úR WURFBILDER */
    /* ================================================== */
    
    /* Der Container (definiert den Hintergrund und Rahmen) */
    .shot-chart-container-half,
    .shot-chart-container-full {
        position: relative;
        width: 100%;
        background-color: #ffffff;
        border: 2px solid #000;
        box-sizing: border-box;
        border-radius: 5px;
        overflow: hidden; 
        margin-top: 15px;
    }
    /* Maximale Breite f√ºr Halbfeld */
    .shot-chart-container-half {
        max-width: 450px; /* Du kannst dies anpassen */
        margin-left: auto;
        margin-right: auto;
    }
    /* Maximale Breite f√ºr Ganzfeld */
    .shot-chart-container-full {
        max-width: 700px; /* Du kannst dies anpassen */
        margin-left: auto;
        margin-right: auto;
    }

    /* Das SVG-Bild selbst (bestimmt die Gr√∂√üe/Form) */
    .svg-handball-pitch {
        width: 100%;
        height: auto; /* L√§sst das SVG seine eigene H√∂he bestimmen */
        display: block; /* Verhindert extra Leerraum */
        z-index: 1; 
    }

    /* Das Overlay f√ºr die Punkte (legt sich √ºber das SVG) */
    .shot-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2; 
    }
    .shot-overlay p { color: #000; opacity: 0.7; }
    
    .stats-table tfoot tr {
        background-color: rgba(0,0,0,0.3); 
        font-weight: bold; 
        border-top: 2px solid #ffcc00;
    }
    .shot-dot {
        position: absolute; width: 12px; height: 12px;
        border-radius: 50%; transform: translate(-50%, -50%);
        border: 2px solid rgba(0,0,0,0.7);
        box-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    .shot-dot.goal { background-color: #38E838; }
    .shot-dot.miss { background-color: #f44336; }
    .shot-dot.tech-error-pass { background-color: #ff9800; }
    .shot-dot.opp-goal { background-color: #9E9E9E; }
    .shot-dot.opp-miss { background-color: #795548; }

    .shot-chart-legend {
        display: flex; justify-content: center;
        gap: 20px; margin-top: 15px;
    }
    .legend-item { display: flex; align-items: center; }
    .legend-color-box {
        width: 15px; height: 15px;
        margin-right: 8px; border: 1px solid rgba(0,0,0,0.5);
        border-radius: 3px;
    }
    .legend-color-box.goal { background-color: #38E838; }
    .legend-color-box.miss { background-color: #f44336; }
    .legend-color-box.tech-error-pass { background-color: #ff9800; }
    .legend-color-box.opp-goal { background-color: #9E9E9E; }
    .legend-color-box.opp-miss { background-color: #795548; }
    
    
    /* ================================================== */
    /* NEU (PHASE 8): Stile f√ºr Video-Schnitt-Center */
    /* ================================================== */
    .video-cutter-layout {
        display: grid;
        grid-template-columns: 1fr 1.2fr; /* 2 Spalten: Filter & Video */
        gap: 20px;
        margin-top: 15px;
    }
    .cutter-controls .form-section {
        margin-bottom: 15px;
    }
    .cutter-controls label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        color: #ffcc00;
    }
    .cutter-controls select {
        width: 100%;
        padding: 10px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        color: #333;
        font-size: 1em;
    }
    #cutter-playlist-container {
        max-height: 350px;
        overflow-y: auto;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 5px;
        background: rgba(0, 0, 0, 0.1);
    }
    .playlist-item {
        padding: 12px 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        cursor: pointer;
        transition: background-color 0.15s;
    }
    .playlist-item:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    .playlist-item.active {
        background-color: #ffcc00;
        color: #1e3c72;
        font-weight: bold;
    }
    .playlist-item .time {
        font-weight: bold;
        color: #38E838;
        margin-right: 10px;
    }
    .playlist-item .opponent {
        font-size: 0.9em;
        opacity: 0.8;
        display: block;
        margin-top: 4px;
    }
    
    #cutter-player-container {
        position: relative;
        padding-bottom: 56.25%; /* 16:9 */
        height: 0;
        overflow: hidden;
        background: #000;
        border-radius: 5px;
    }
    #cutter-youtube-player {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    #cutter-video-title {
        margin-top: 10px;
        margin-bottom: 0;
        text-align: center;
        color: #fff;
        opacity: 0.9;
    }
    
</style>

<div class="analysis-grid-1-col">
    
    <div class="card">
        <div class="card-content">
            <h2>üé¨ Video-Schnitt-Center (Saison)</h2>
            <p style="opacity: 0.8; font-size: 0.9em;">
                Filtern Sie Aktionen aus allen Saisonspielen, f√ºr die ein Video-Zeitstempel
                im Protokoll gesetzt wurde. Klicken Sie auf einen Eintrag, um die Szene abzuspielen.
            </p>
            
            <div class="video-cutter-layout">
                <div class="cutter-controls">
                    <div class="form-section active">
                        <label for="cutter-player-select">Spieler ausw√§hlen:</label>
                        <select id="cutter-player-select">
                            <option value="all" selected>Alle Spieler</option>
                            </select>
                    </div>
                    <div class="form-section active">
                        <label for="cutter-action-select">Aktion ausw√§hlen:</label>
                        <select id="cutter-action-select">
                            <option value="all" selected>Alle Aktionen</option>
                            </select>
                    </div>
                    <div class="form-section active">
                        <label for="cutter-game-select">Spiel ausw√§hlen:</label>
                        <select id="cutter-game-select">
                            <option value="all" selected>Alle Spiele</option>
                            </select>
                    </div>
                    
                    <h3 style="margin-top: 20px; margin-bottom: 10px;">Schnitt-Liste (Playlist)</h3>
                    <div id="cutter-playlist-container">
                        <p style="opacity: 0.6; text-align: center; padding: 20px;">
                            Bitte Team w√§hlen und Statistik laden...
                        </p>
                    </div>
                </div>
                
                <div class="cutter-video">
                    <div id="cutter-player-container">
                        <div id="cutter-youtube-player" style="display: flex; align-items: center; justify-content: center; color: #aaa;">
                            Video-Player
                        </div>
                    </div>
                    <h4 id="cutter-video-title">(Kein Video geladen)</h4>
                </div>
            </div>
            
        </div>
    </div>
    <div>
        <div class="card" style="margin-top: 20px;">
          <div class="card-content">
            <h2>Saison-Statistik (Aggregiert)</h2>
            <h3><span id="season-stats-team-name" style="color: #ffcc00;">(Team w√§hlen)</span></h3>
            <button class="btn btn-secondary btn-full-width" id="load-season-stats-btn" disabled>
                Saison-Statistik laden
            </button>
            <div id="season-stats-message" class="message"></div>
            
            <h3 style="margin-top: 20px;">Gegner-Statistik (Saison)</h3>
            <div id="stats-table-container-opponent-season">
                <p style="opacity: 0.6; text-align: center;">Bitte Team w√§hlen und Statistik laden.</p>
            </div>
            
            <h3 style="margin-top: 20px;">Feldspieler-Statistik (Saison)</h3>
            <div class="stats-table-container" id="stats-table-container-field-season">
                <p style="opacity: 0.6; text-align: center;">Bitte Team w√§hlen und Statistik laden.</p>
            </div>
            
            <h3 style="margin-top: 20px;">Torwart-Statistik (Saison)</h3>
            <div class="stats-table-container" id="stats-table-container-goalie-season"></div>
    
            <h3 style="margin-top: 20px;">Team-Aktionen Statistik (Saison)</h3>
            <div class="stats-table-container" id="stats-table-container-custom-season"></div>
    
            <hr style="border-color: rgba(255,255,255,0.2); margin: 30px 0;">
            <h3>Saison-Archivierung (Reset)</h3>
            <p style="opacity: 0.8; font-size: 0.9em;">
                Hiermit werden alle Spiele der Kategorie "Saison" in ein Archiv verschoben.
            </p>
            <div class="form-section active">
                <label for="archive-name-input">Name f√ºr das Archiv (z.B. "Saison 2024/25"):</label>
                <input type="text" id="archive-name-input" placeholder="Name des Archivs" required>
            </div>
            <button id="archive-season-btn" class="btn btn-danger btn-full-width" disabled>
                Aktive Saison jetzt archivieren
            </button>
            <div id="archive-message" class="message"></div>
          </div>
        </div>
        
        <div class="card" style="margin-top: 20px;">
            <div class="card-content">
                <h2>Saison Wurfbild (Shot Chart)</h2>
                <p style="opacity: 0.8; font-size: 0.9em;">
                    Zeigt alle erfassten W√ºrfe (Tore/Fehlw√ºrfe) aus Saisonspielen.
                </p>
                <label for="shot-chart-player-select">Spieler ausw√§hlen:</label>
                <select id="shot-chart-player-select">
                    <option value="" disabled selected>Statistik laden...</option>
                </select>
                
                <div class="shot-chart-container-half"> 
                    <img src="/static/halbfeld_links.svg" class="svg-handball-pitch" alt="Handball-Halbfeld">
                    <div class="shot-overlay" id="shot-chart-overlay"></div>
                </div>
                
                <div class="shot-chart-legend">
                    <div class="legend-item">
                        <span class="legend-color-box goal"></span> <span>Tor</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color-box miss"></span> <span>Fehlwurf</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-top: 20px;">
            <div class="card-content">
                <h2>Saison Fehlerbild (Error Chart)</h2>
                <p style="opacity: 0.8; font-size: 0.9em;">
                    Zeigt alle Technischen Fehler & Fehlp√§sse aus Saisonspielen.
                </p>
                <label for="error-chart-player-select">Spieler ausw√§hlen:</label>
                <select id="error-chart-player-select">
                    <option value="" disabled selected>Statistik laden...</option>
                </select>
                
                <div class="shot-chart-container-full">
                    <img src="/static/ganzfeld.svg" class="svg-handball-pitch" alt="Handball-Ganzfeld">
                    <div class="shot-overlay" id="error-chart-overlay"></div>
                </div>
                
                <div class="shot-chart-legend">
                    <div class="legend-item">
                        <span class="legend-color-box miss"></span> <span>Tech. Fehler</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color-box tech-error-pass"></span> <span>Fehlpass</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-top: 20px;">
            <div class="card-content">
                <h2>Gegner Wurfbild (Saison)</h2>
                <p style="opacity: 0.8; font-size: 0.9em;">
                    Zeigt alle erfassten W√ºrfe (Tore/Fehlw√ºrfe) des Gegners (zur Torwart-Analyse).
                </p>
                
                <div class="shot-chart-container-half">
                    <img src="/static/halbfeld_links.svg" class="svg-handball-pitch" alt="Handball-Halbfeld (Gegner)">
                    <div class="shot-overlay" id="opponent-shot-chart-overlay"></div>
                </div>
                
                <div class="shot-chart-legend">
                    <div class="legend-item">
                        <span class="legend-color-box opp-goal"></span> <span>Gegner Tor</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color-box opp-miss"></span> <span>Gegner Fehlwurf</span>
                    </div>
                </div>
            </div>
        </div>
        
    </div>
    
</div>

<script>
    // Globale Variablen (nur f√ºr Saison-Analyse)
    let selectedTeamId = localStorage.getItem('selected_team_id');
    let selectedTeamName = localStorage.getItem('selected_team_name');
    let seasonShotData = [];
    let seasonErrorData = [];
    let seasonOpponentShotData = [];
    
    // ==================================================
    // NEU (PHASE 8): Globale Variablen f√ºr Video-Schnitt-Center
    // ==================================================
    let seasonActionData = []; // Speichert Roh-Aktionen vom neuen API-Endpunkt
    let cutterPlayer = null; // YouTube-Player-Instanz
    let cutterPlayerReady = false; // Status-Flag
    let activePlaylistItem = null; // F√ºr CSS-Highlighting
    let lastLoadedVideoId = null; // Um unn√∂tiges Neuladen zu verhindern

    // DOM-Elemente
    const seasonStatsTeamName = document.getElementById('season-stats-team-name');
    const loadSeasonStatsBtn = document.getElementById('load-season-stats-btn');
    const seasonStatsMessage = document.getElementById('season-stats-message');
    const statsContainerFieldSeason = document.getElementById('stats-table-container-field-season');
    const statsContainerGoalieSeason = document.getElementById('stats-table-container-goalie-season');
    const statsContainerCustomSeason = document.getElementById('stats-table-container-custom-season');
    const statsContainerOpponentSeason = document.getElementById('stats-table-container-opponent-season');
    const archiveNameInput = document.getElementById('archive-name-input');
    const archiveSeasonBtn = document.getElementById('archive-season-btn');
    const archiveMessageDiv = document.getElementById('archive-message');
    
    // Wurfbild (Shot Chart) Elemente
    const shotChartPlayerSelect = document.getElementById('shot-chart-player-select');
    const shotChartOverlay = document.getElementById('shot-chart-overlay');
    
    // Fehlerbild (Error Chart) Elemente
    const errorChartPlayerSelect = document.getElementById('error-chart-player-select');
    const errorChartOverlay = document.getElementById('error-chart-overlay');
    
    // Gegner-Wurfbild Elemente
    const opponentShotChartOverlay = document.getElementById('opponent-shot-chart-overlay');
    
    // ==================================================
    // NEU (PHASE 8): DOM-Elemente f√ºr Video-Schnitt-Center
    // ==================================================
    const cutterPlayerSelect = document.getElementById('cutter-player-select');
    const cutterActionSelect = document.getElementById('cutter-action-select');
    const cutterGameSelect = document.getElementById('cutter-game-select');
    const cutterPlaylistContainer = document.getElementById('cutter-playlist-container');
    const cutterVideoTitle = document.getElementById('cutter-video-title');
    
    // Event Listeners f√ºr die neuen Filter
    cutterPlayerSelect.addEventListener('change', renderCutterPlaylist);
    cutterActionSelect.addEventListener('change', renderCutterPlaylist);
    cutterGameSelect.addEventListener('change', renderCutterPlaylist);

    // --- Saison-Statistik Logik ---
    loadSeasonStatsBtn.addEventListener('click', loadSeasonStats);

    async function loadSeasonStats() {
        if (!selectedTeamId) {
             seasonStatsMessage.textContent = '‚ùå Fehler: Bitte zuerst Team ausw√§hlen.';
             seasonStatsMessage.className = 'message error';
             return;
        }
        seasonStatsMessage.textContent = 'Lade Saison-Statistik...';
        seasonStatsMessage.className = 'message';
        statsContainerOpponentSeason.innerHTML = '<p style="opacity: 0.6; text-align: center;">Lade...</p>';
        statsContainerFieldSeason.innerHTML = '<p style="opacity: 0.6; text-align: center;">Lade...</p>';
        statsContainerGoalieSeason.innerHTML = '<p style="opacity: 0.6; text-align: center;">Lade...</p>';
        statsContainerCustomSeason.innerHTML = '<p style="opacity: 0.6; text-align: center;">Lade...</p>';
        
        // Wurfbild-Daten laden
        loadShotChartData();
        loadErrorChartData();
        loadOpponentShotChartData(); 
        
        // NEU (PHASE 8): Playlist-Daten laden
        loadSeasonActionData();

        try {
            const [playerStatsResponse, opponentStatsResponse] = await Promise.all([
                fetch(`/actions/stats/season/${selectedTeamId}`),
                fetch(`/actions/stats/season/opponent/${selectedTeamId}`)
            ]);
            if (playerStatsResponse.status === 401 || opponentStatsResponse.status === 401) { logout(); }
            if (!playerStatsResponse.ok) throw new Error('Spieler-Statistikdaten konnten nicht abgerufen werden.');
            if (!opponentStatsResponse.ok) throw new Error('Gegner-Statistikdaten konnten nicht abgerufen werden.');
            
            const playerStats = await playerStatsResponse.json();
            const opponentStats = await opponentStatsResponse.json();
            seasonStatsMessage.textContent = '‚úÖ Statistik erfolgreich geladen.';
            seasonStatsMessage.className = 'message success';
            displaySeasonPlayerStats(playerStats, 'stats-table-container-');
            displaySeasonOpponentStats(opponentStats, statsContainerOpponentSeason); 
        } catch (error) {
            seasonStatsMessage.textContent = '‚ùå FEHLER beim Laden der Statistik.';
            seasonStatsMessage.className = 'message error';
            statsContainerFieldSeason.innerHTML = `<p class="error">FEHLER beim Laden der Statistik.</p>`;
            statsContainerOpponentSeason.innerHTML = `<p class="error">FEHLER beim Laden der Statistik.</p>`;
            statsContainerGoalieSeason.innerHTML = '';
            statsContainerCustomSeason.innerHTML = '';
            console.error("Saison-Statistikfehler:", error);
        }
    }
    
    function displaySeasonOpponentStats(stats, targetContainer) {
        // ... (Funktion unver√§ndert) ...
        if (!targetContainer) { return; }
        let tableHtml = `<table class="opponent-stats-table"><tbody>
            <tr><td>üü° Gegner Tore (Gesamt)</td><td>${stats.opponent_goals}</td></tr>
            <tr><td>üí® Gegner Fehlw√ºrfe</td><td>${stats.opponent_misses}</td></tr>
            <tr><td>üö´ Gegner Tech. Fehler</td><td>${stats.opponent_tech_errors}</td></tr>
        </tbody></table>`;
        targetContainer.innerHTML = tableHtml;
    }

    function displaySeasonPlayerStats(stats, containerPrefix) {
        // ... (Funktion unver√§ndert) ...
        const fieldContainer = document.getElementById(`${containerPrefix}field-season`);
        const goalieContainer = document.getElementById(`${containerPrefix}goalie-season`);
        const customContainer = document.getElementById(`${containerPrefix}custom-season`);
        if (!fieldContainer || !goalieContainer || !customContainer) { console.error("Statistik-Container nicht gefunden. Pr√§fix:", containerPrefix); return; }
        let fieldHeaders = [{ key: 'player_name', name: 'Spieler', isFixed: true }, { key: 'player_number', name: '#', isFixed: true },{ key: 'games_played', name: 'Spiele' }, { key: 'goals', name: 'Tore (Quote)' }, { key: 'tore_pro_spiel', name: 'Tore/Spiel' }, { key: 'misses', name: 'Fehlw√ºrfe' },{ key: 'tech_errors', name: 'Tech. Fehler / Fehlp√§sse' }, { key: 'seven_meter_goals', name: '7m Tor' },{ key: 'seven_meter_misses', name: '7m Fehl' }, { key: 'seven_meter_caused', name: '7m Verursacht' }];
        let goalieHeaders = [{ key: 'player_name', name: 'Spieler', isFixed: true }, { key: 'player_number', name: '#', isFixed: true },{ key: 'games_played', name: 'Spiele' }, { key: 'saves', name: 'Paraden Ges. (Quote)' }, { key: 'seven_meter_saves', name: '7m-Quote' }];
        let fieldTableHtml = `<table class="stats-table"><thead><tr>`;
        fieldHeaders.forEach(h => { fieldTableHtml += `<th>${h.name}</th>`; });
        fieldTableHtml += `</tr></thead><tbody>`;
        let goalieTableHtml = `<table class="stats-table"><thead><tr>`;
        goalieHeaders.forEach(h => { goalieTableHtml += `<th>${h.name}</th>`; });
        goalieTableHtml += `</tr></thead><tbody>`;
        let fieldPlayersFound = false, goaliesFound = false;
        if (stats.length === 0) {
             fieldContainer.innerHTML = '<p style="opacity: 0.6; text-align: center;">Keine Spielerdaten.</p>';
             goalieContainer.innerHTML = '<p style="opacity: 0.6; text-align: center;">Keine Torwartdaten.</p>';
             customContainer.innerHTML = '<p style="opacity: 0.6; text-align: center;">Keine Team-Aktionen.</p>';
             return;
        }
        let totalGoals = 0, totalShots = 0, totalTechErrors = 0, totalFehlpaesse = 0, totalSevenMeterCaused = 0, totalSevenMeterAttempts = 0, totalSevenMeterGoals = 0, totalGamesPlayed = 0, totalFieldPlayers = 0;
        stats.forEach(player => {
            if (player.position === 'Torwart') {
                goaliesFound = true; goalieTableHtml += `<tr>`;
                goalieHeaders.forEach(h => {
                    let value = player[h.key] !== undefined ? player[h.key] : 0;
                    if (h.name === 'Paraden Ges. (Quote)') { const totalSaves = player.saves + player.seven_meter_saves; const totalGoalsReceived = player.opponent_goals_received + player.seven_meter_received; const totalShotsOnGoal = totalSaves + totalGoalsReceived; const quote = totalShotsOnGoal > 0 ? ((totalSaves / totalShotsOnGoal) * 100).toFixed(0) + '%' : '‚Äî'; value = `${totalSaves} (${quote})`; }
                    if (h.name === '7m-Quote') { const totalSevenMetersOnGoal = player.seven_meter_saves + player.seven_meter_received; const quote = totalSevenMetersOnGoal > 0 ? ((player.seven_meter_saves / totalSevenMetersOnGoal) * 100).toFixed(0) + '%' : '‚Äî'; value = `${player.seven_meter_saves} / ${totalSevenMetersOnGoal} (${quote})`; }
                    if (h.name === 'Tore (Quote)') { const totalShots = player.goals + player.misses + player.seven_meter_goals + player.seven_meter_misses; const totalGoals = player.goals + player.seven_meter_goals; const quote = totalShots > 0 ? ((totalGoals / totalShots) * 100).toFixed(0) + '%' : '‚Äî'; value = `${totalGoals} (${quote})`; }
                    if (h.name === 'Tore/Spiel') { if (player.games_played > 0) { const totalGoals = player.goals + player.seven_meter_goals; value = (totalGoals / player.games_played).toFixed(1); } else { value = '0.0'; } }
                    goalieTableHtml += `<td>${value}</td>`;
                });
                goalieTableHtml += `</tr>`;
            } else {
                fieldPlayersFound = true; totalFieldPlayers++; const currentTotalGoals = player.goals + player.seven_meter_goals; const currentTotalShots = currentTotalGoals + player.misses + player.seven_meter_misses;
                fieldTableHtml += `<tr>`;
                fieldHeaders.forEach(h => {
                    let value = player[h.key] !== undefined ? player[h.key] : 0;
                    if (h.name === 'Tore (Quote)') { const quote = currentTotalShots > 0 ? ((currentTotalGoals / currentTotalShots) * 100).toFixed(0) + '%' : '‚Äî'; value = `${currentTotalGoals} (${quote})`; }
                    if (h.name === 'Tore/Spiel') { if (player.games_played > 0) { value = (currentTotalGoals / player.games_played).toFixed(1); } else { value = '0.0'; } }
                    if (h.name === 'Fehlw√ºrfe') { value = player.misses + player.seven_meter_misses; }
                    if (h.name === 'Tech. Fehler / Fehlp√§sse') { value = `${player.tech_errors} / ${player.fehlpaesse}`; }
                    fieldTableHtml += `<td>${value}</td>`;
                });
                fieldTableHtml += `</tr>`;
                totalGoals += currentTotalGoals; totalShots += currentTotalShots; totalTechErrors += player.tech_errors; totalFehlpaesse += player.fehlpaesse; totalSevenMeterCaused += player.seven_meter_caused; totalSevenMeterAttempts += player.seven_meter_goals + player.seven_meter_misses; totalSevenMeterGoals += player.seven_meter_goals; totalGamesPlayed += player.games_played;
            }
        });
        const totalShotQuote = totalShots > 0 ? ((totalGoals / totalShots) * 100).toFixed(0) + '%' : '‚Äî'; const avgGames = totalFieldPlayers > 0 ? (totalGamesPlayed / totalFieldPlayers).toFixed(0) : 0; const avgGoalsPerGame = parseFloat(avgGames) > 0 ? (totalGoals / parseFloat(avgGames)).toFixed(1) : (totalGamesPlayed > 0 ? (totalGoals / totalGamesPlayed).toFixed(1) : "0.0");
        fieldTableHtml += `</tbody><tfoot><tr><td>TOTAL TEAM</td><td>-</td><td>${avgGames}</td><td>${totalGoals} (${totalShotQuote})</td><td>${avgGoalsPerGame}</td><td>${totalShots - totalGoals}</td><td>${totalTechErrors} / ${totalFehlpaesse}</td><td>${totalSevenMeterGoals}</td><td>${totalSevenMeterAttempts - totalSevenMeterGoals}</td><td>${totalSevenMeterCaused}</td></tr></tfoot></table>`;
        goalieTableHtml += `</tbody></table>`;
        fieldContainer.innerHTML = fieldPlayersFound ? fieldTableHtml : '<p style="opacity: 0.6; text-align: center;">Keine Feldspieler im Kader.</p>';
        goalieContainer.innerHTML = goaliesFound ? goalieTableHtml : '<p style="opacity: 0.6; text-align: center;">Keine Torh√ºter im Kader.</p>';
        const customActionNames = (stats.length > 0 && stats[0].custom_counts) ? Object.keys(stats[0].custom_counts) : [];
        if (customActionNames.length === 0) { customContainer.innerHTML = '<p style="opacity: 0.6; text-align: center;">Keine Team-Aktionen definiert.</p>'; } else {
            let customTableHtml = `<table class="stats-table"><thead><tr><th>Spieler</th><th>#</th><th>Spiele</th>`;
            customActionNames.forEach(name => { customTableHtml += `<th>${name}</th>`; });
            customTableHtml += `</tr></thead><tbody>`;
            stats.forEach(player => {
                if (player.position !== 'Torwart' && player.games_played > 0) {
                    customTableHtml += `<tr><td>${player.player_name}</td><td>${player.player_number || ''}</td><td>${player.games_played}</td>`; 
                    customActionNames.forEach(name => { customTableHtml += `<td>${player.custom_counts[name] || 0}</td>`; });
                    customTableHtml += `</tr>`;
                }
            });
            customTableHtml += `</tbody></table>`; customContainer.innerHTML = customTableHtml;
        }
    }


    // --- Archivierungs-Funktion (Unver√§ndert) ---
    archiveSeasonBtn.addEventListener('click', handleArchiveSeason);
    async function handleArchiveSeason() {
        // ... (Funktion unver√§ndert) ...
        if (!checkVerification()) { return; }
        if (!selectedTeamId) return;
        const archiveName = archiveNameInput.value.trim();
        if (!archiveName) {
            archiveMessageDiv.textContent = '‚ùå Bitte einen Namen f√ºr das Archiv eingeben.';
            archiveMessageDiv.className = 'message error';
            return;
        }
        if (!confirm(`Sind Sie sicher? \n\nAlle ${selectedTeamName}-Spiele der Kategorie "Saison" werden unwiderruflich in das Archiv "${archiveName}" verschoben. \n\nDie Saison-Statistik wird dadurch zur√ºckgesetzt.`)) {
            return;
        }
        archiveMessageDiv.textContent = 'Archiviere Saison...';
        archiveMessageDiv.className = 'message';
        try {
            const response = await fetch(`/games/archive/season/${selectedTeamId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ archive_name: archiveName }),
            });
            const data = await response.json();
            if (response.ok) {
                archiveMessageDiv.textContent = `‚úÖ ${data.message}`;
                archiveMessageDiv.className = 'message success';
                archiveNameInput.value = ''; 
                loadSeasonStats();
                if (typeof initGamePlanning === 'function') initGamePlanning();
            } else if (response.status === 401 || response.status === 403) {
                logout();
            } else {
                archiveMessageDiv.textContent = `‚ùå Fehler: ${data.detail || 'Unbekannter Fehler'}`;
                archiveMessageDiv.className = 'message error';
            }
        } catch (error) {
            archiveMessageDiv.textContent = '‚ùå Serverfehler bei der Archivierung.';
            archiveMessageDiv.className = 'message error';
            console.error("Archiv-Fehler:", error);
        }
    }

    // --- FUNKTIONEN F√úR WURFBILD (SHOT CHART) ---
    shotChartPlayerSelect.addEventListener('change', (e) => {
        renderShotChart(e.target.value, shotChartOverlay, seasonShotData);
    });

    async function loadShotChartData() {
        // ... (Funktion unver√§ndert) ...
        if (!selectedTeamId) {
            shotChartPlayerSelect.innerHTML = '<option value="" disabled selected>Team w√§hlen...</option>';
            return;
        }
        shotChartPlayerSelect.innerHTML = '<option value="" disabled selected>Lade Wurfdaten...</option>';
        shotChartOverlay.innerHTML = '';
        try {
            const response = await fetch(`/actions/shots/season/${selectedTeamId}`);
            if (response.status === 401) { logout(); return; }
            if (!response.ok) throw new Error('Wurfdaten konnten nicht geladen werden.');
            seasonShotData = await response.json();
            shotChartPlayerSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all'; allOption.textContent = 'Alle Spieler';
            shotChartPlayerSelect.appendChild(allOption);
            seasonShotData.forEach(playerData => {
                const option = document.createElement('option');
                option.value = playerData.player_id;
                option.textContent = `#${playerData.player_number || '?'} ${playerData.player_name}`;
                shotChartPlayerSelect.appendChild(option);
            });
            shotChartPlayerSelect.value = 'all';
            renderShotChart('all', shotChartOverlay, seasonShotData); 
        } catch (error) {
            shotChartPlayerSelect.innerHTML = '<option value="" disabled selected>Fehler beim Laden</option>';
            shotChartOverlay.innerHTML = '<p class="error" style="text-align: center; padding-top: 22%; color: black;">Fehler beim Laden der Wurfdaten.</p>';
            console.error("Shot Chart Error:", error);
        }
    }

    function renderShotChart(playerId, targetOverlay, data) {
        // ... (Funktion KORRIGIERT f√ºr Phase 8.5) ...
        targetOverlay.innerHTML = ''; let shotsToRender = [];
        if (playerId === 'all') {
            data.forEach(playerData => { shotsToRender.push(...playerData.shots); });
        } else {
            const playerData = data.find(p => p.player_id == playerId);
            if (playerData) { shotsToRender = playerData.shots; }
        }
        
        // KORRIGIERT: Pr√ºft, ob es ein Halbfeld ist
        const isHalfField = targetOverlay.parentElement.classList.contains('shot-chart-container-half');
        const emptyMessagePadding = isHalfField ? '45%' : '22%'; // Passt "Keine Daten" an
        
        if (shotsToRender.length === 0) {
            targetOverlay.innerHTML = `<p style="opacity: 0.6; text-align: center; padding-top: ${emptyMessagePadding}; color: black;">Keine Wurfdaten.</p>`;
            return;
        }
        shotsToRender.forEach(shot => {
            const dot = document.createElement('div');
            const isGoal = shot.action_type === 'Goal' || shot.action_type === 'Goal_7m';
            dot.className = `shot-dot ${isGoal ? 'goal' : 'miss'}`;
            if (shot.x_coordinate <= 50) { 
                if (isHalfField) {
                    // Mappt 0-50 (Ganzfeld) auf 0-100 (Halbfeld)
                    dot.style.left = `${shot.x_coordinate * 2}%`; 
                } else {
                    dot.style.left = `${shot.x_coordinate}%`; 
                }
                dot.style.top = `${shot.y_coordinate}%`;
                targetOverlay.appendChild(dot);
            }
        });
    }

    // --- FUNKTIONEN F√úR FEHLERBILD (ERROR CHART) ---
    errorChartPlayerSelect.addEventListener('change', (e) => {
        renderErrorChart(e.target.value, errorChartOverlay, seasonErrorData);
    });
    
    async function loadErrorChartData() {
        // ... (Funktion unver√§ndert) ...
        if (!selectedTeamId) {
            errorChartPlayerSelect.innerHTML = '<option value="" disabled selected>Team w√§hlen...</option>';
            return;
        }
        errorChartPlayerSelect.innerHTML = '<option value="" disabled selected>Lade Fehlerdaten...</option>';
        errorChartOverlay.innerHTML = '';
        try {
            const response = await fetch(`/actions/stats/errors/season/${selectedTeamId}`);
            if (response.status === 401) { logout(); return; }
            if (!response.ok) { throw new Error(`Fehlerdaten konnten nicht geladen werden.`); }
            seasonErrorData = await response.json(); 
            errorChartPlayerSelect.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'all'; allOption.textContent = 'Alle Spieler';
            errorChartPlayerSelect.appendChild(allOption);
            seasonErrorData.forEach(playerData => {
                const option = document.createElement('option');
                option.value = playerData.player_id;
                option.textContent = `#${playerData.player_number || '?'} ${playerData.player_name}`;
                errorChartPlayerSelect.appendChild(option);
            });
            errorChartPlayerSelect.value = 'all';
            renderErrorChart('all', errorChartOverlay, seasonErrorData); 
        } catch (error) {
            errorChartPlayerSelect.innerHTML = '<option value="" disabled selected>Fehler beim Laden</option>';
            errorChartOverlay.innerHTML = '<p class="error" style="text-align: center; padding-top: 22%; color: black;">Fehler beim Laden der Fehlerdaten.</p>';
            console.error("Error Chart Error:", error);
        }
    }

    function renderErrorChart(playerId, targetOverlay, data) {
        // ... (Funktion unver√§ndert) ...
        targetOverlay.innerHTML = ''; let errorsToRender = [];
        if (playerId === 'all') {
            data.forEach(playerData => { errorsToRender.push(...playerData.shots); });
        } else {
            const playerData = data.find(p => p.player_id == playerId);
            if (playerData) { errorsToRender = playerData.shots; }
        }
        
        // DIESES BLEIBT IMMER GANZFELD
        const emptyMessagePadding = '22%';
        
        if (errorsToRender.length === 0) {
            targetOverlay.innerHTML = `<p style="opacity: 0.6; text-align: center; padding-top: ${emptyMessagePadding}; color: black;">Keine Fehlerdaten.</p>`;
            return;
        }
        errorsToRender.forEach(error => {
            const dot = document.createElement('div');
            const isFehlpass = error.action_type === 'Fehlpass';
            dot.className = `shot-dot ${isFehlpass ? 'tech-error-pass' : 'miss'}`;
            dot.style.left = `${error.x_coordinate}%`;
            dot.style.top = `${error.y_coordinate}%`;
            targetOverlay.appendChild(dot);
        });
    }

    // --- FUNKTIONEN F√úR GEGNER-WURFBILD (Phase 9) ---
    async function loadOpponentShotChartData() {
        // ... (Funktion unver√§ndert) ...
        if (!selectedTeamId) {
            opponentShotChartOverlay.innerHTML = '';
            return;
        }
        opponentShotChartOverlay.innerHTML = '<p style="opacity: 0.6; text-align: center; padding-top: 22%; color: black;">Lade Gegner-Wurfdaten...</p>';
        try {
            const response = await fetch(`/actions/shots/opponent/season/${selectedTeamId}`);
            if (response.status === 401) { logout(); return; }
            if (!response.ok) { throw new Error(`Gegner-Wurfdaten konnten nicht geladen werden.`); }
            seasonOpponentShotData = await response.json(); 
            renderOpponentShotChart(opponentShotChartOverlay, seasonOpponentShotData); 
        } catch (error) {
            opponentShotChartOverlay.innerHTML = '<p class="error" style="text-align: center; padding-top: 22%; color: black;">Fehler beim Laden der Gegner-Wurfdaten.</p>';
            console.error("Opponent Shot Chart Error:", error);
        }
    }

    function renderOpponentShotChart(targetOverlay, data) {
        // ... (Funktion KORRIGIERT f√ºr Phase 8.5) ...
        targetOverlay.innerHTML = ''; const shotsToRender = data;
        
        // KORRIGIERT: Pr√ºft, ob es ein Halbfeld ist
        const isHalfField = targetOverlay.parentElement.classList.contains('shot-chart-container-half');
        const emptyMessagePadding = isHalfField ? '45%' : '22%'; // Passt "Keine Daten" an
        
        if (shotsToRender.length === 0) {
            targetOverlay.innerHTML = `<p style="opacity: 0.6; text-align: center; padding-top: ${emptyMessagePadding}; color: black;">Keine Gegner-Wurfdaten.</p>`;
            return;
        }
        shotsToRender.forEach(shot => {
            const dot = document.createElement('div');
            const isGoal = shot.action_type === 'OppGoal';
            dot.className = `shot-dot ${isGoal ? 'opp-goal' : 'opp-miss'}`;
            if (shot.x_coordinate > 50) { // Nur W√ºrfe auf das eigene Tor (rechte H√§lfte)
                if (isHalfField) {
                    // Mappt 50-100 (Ganzfeld) auf 0-100 (Halbfeld)
                    const newX = (shot.x_coordinate - 50) * 2;
                    dot.style.left = `${newX}%`;
                } else {
                    dot.style.left = `${shot.x_coordinate}%`;
                }
                dot.style.top = `${shot.y_coordinate}%`;
                targetOverlay.appendChild(dot);
            }
        });
    }
    
    
    // ==================================================
    // KORRIGIERT (PHASE 8): Funktionen f√ºr Video-Schnitt-Center
    // ==================================================

    // 1. YouTube API laden (wird von init aufgerufen)
    function loadYouTubeAPI() {
        if (typeof(YT) == 'undefined' || typeof(YT.Player) == 'undefined') {
            var tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            
            // Setze den globalen Callback
            window.onYouTubeIframeAPIReady = onCutterYouTubeIframeAPIReady;
        } else {
            onCutterYouTubeIframeAPIReady();
        }
    }
    
    // 2. KORRIGIERTER Callback: Erstellt den Player NICHT sofort
    function onCutterYouTubeIframeAPIReady() {
        console.log("Saison-Analyse: YouTube API ist bereit.");
        // Setze NUR das Flag. Erstelle den Player noch NICHT.
        // Der Player wird beim ersten Klick auf "playScene" erstellt.
        cutterPlayerReady = true;
    }
    
    // 3. Hilfsfunktion: Video-ID aus URL extrahieren (kopiert aus protocol.html)
    function extractVideoID(url) {
        if (!url) return null;
        let videoID = url; 
        try {
            const urlObj = new URL(url, 'https://www.youtube.com');
            if (urlObj.hostname === 'youtu.be') {
                videoID = urlObj.pathname.substring(1);
            } else {
                const urlParams = urlObj.searchParams;
                if (urlParams.has('v')) {
                    videoID = urlParams.get('v');
                }
            }
        } catch(e) {}
        if (/^[a-zA-Z0-9_-]{11}$/.test(videoID)) {
            return videoID;
        }
        return null; 
    }
    
    // 4. Rohdaten aller Saison-Aktionen laden
    async function loadSeasonActionData() {
        if (!selectedTeamId) return;
        cutterPlaylistContainer.innerHTML = '<p style="opacity: 0.6; text-align: center; padding: 20px;">Lade Aktionsdaten...</p>';
        
        try {
            const response = await fetch(`/actions/list/season/${selectedTeamId}`);
            if (response.status === 401) { logout(); return; }
            if (!response.ok) throw new Error('Aktions-Rohdaten konnten nicht geladen werden.');
            
            seasonActionData = await response.json();
            populateCutterFilters();
            renderCutterPlaylist();
            
        } catch (error) {
            console.error("Fehler beim Laden der Saison-Aktionen:", error);
            cutterPlaylistContainer.innerHTML = '<p class="error">Fehler beim Laden der Aktionsdaten.</p>';
        }
    }

    // 5. KORRIGIERTE Filter-Dropdowns-Bef√ºllung
    function populateCutterFilters() {
        const players = new Map();
        const actions = new Map();
        const games = new Map();

        // (Text-Map f√ºr Aktionen, kopiert aus protocol.html)
        const actionTextMap = {
            'Goal': '‚öΩ TOR (Feld)', 'Miss': 'üí® Fehlwurf (Feld)',
            'Goal_7m': 'üéØ TOR (7m)', 'Miss_7m': 'üß± Fehlwurf (7m)', 
            'TechError': 'üö´ Technischer Fehler', 'Fehlpass': 'üö´ Fehlpass', 
            'Save': 'üõë Parade', 'SEVEN_METER_CAUSED': 'üö® 7m verursacht',
            'SEVEN_METER_SAVE': 'üß± 7m Gehalten', 'SEVEN_METER_RECEIVED': 'üü° 7m Bekommen', 
            'OppGoal': 'üü° Gegner Tor', 'OppMiss': 'üí® Gegner Fehlwurf',
            'OppTechError': 'üö´ Gegner Tech. Fehler'
        };

        seasonActionData.forEach(a => {
            // KORRIGIERT: Nur Aktionen mit gesetztem Zeitstempel in Filter aufnehmen
            if (a.video_timestamp !== null) {
                if (a.player_name && !players.has(a.player_id)) {
                    players.set(a.player_id, `#${a.player_number || '?'} ${a.player_name}`);
                }
                if (!actions.has(a.action_type)) {
                    actions.set(a.action_type, actionTextMap[a.action_type] || a.action_type);
                }
                if (!games.has(a.game_id)) {
                    games.set(a.game_id, `vs. ${a.game_opponent}`);
                }
            }
        });

        // Spieler-Filter f√ºllen
        cutterPlayerSelect.innerHTML = '<option value="all" selected>Alle Spieler</option>';
        players.forEach((name, id) => {
            cutterPlayerSelect.innerHTML += `<option value="${id}">${name}</option>`;
        });
        
        // Aktionen-Filter f√ºllen
        cutterActionSelect.innerHTML = '<option value="all" selected>Alle Aktionen</option>';
        actions.forEach((name, id) => {
            cutterActionSelect.innerHTML += `<option value="${id}">${name}</option>`;
        });
        
        // Spiele-Filter f√ºllen
        cutterGameSelect.innerHTML = '<option value="all" selected>Alle Spiele</option>';
        games.forEach((name, id) => {
            cutterGameSelect.innerHTML += `<option value="${id}">${name}</option>`;
        });
    }

    // 6. KORRIGIERTE Playlist-Render-Funktion
    function renderCutterPlaylist() {
        const playerId = cutterPlayerSelect.value;
        const actionType = cutterActionSelect.value;
        const gameId = cutterGameSelect.value;
        
        let filteredActions = seasonActionData;
        
        // KORRIGIERT: Filtert Aktionen, bei denen nie ein Zeitstempel gesetzt wurde (null)
        filteredActions = filteredActions.filter(a => a.video_timestamp !== null);
        
        if (playerId !== 'all') {
            filteredActions = filteredActions.filter(a => a.player_id == playerId);
        }
        if (actionType !== 'all') {
            filteredActions = filteredActions.filter(a => a.action_type === actionType);
        }
        if (gameId !== 'all') {
            filteredActions = filteredActions.filter(a => a.game_id == gameId);
        }
        
        cutterPlaylistContainer.innerHTML = '';
        activePlaylistItem = null; // Reset Highlight
        
        if (filteredActions.length === 0) {
            cutterPlaylistContainer.innerHTML = '<p style="opacity: 0.6; text-align: center; padding: 20px;">Keine Szenen f√ºr diese Filter gefunden.</p>';
            return;
        }
        
        // (Text-Map f√ºr Aktionen, kopiert aus protocol.html)
        const actionTextMap = {
            'Goal': '‚öΩ TOR (Feld)', 'Miss': 'üí® Fehlwurf (Feld)',
            'Goal_7m': 'üéØ TOR (7m)', 'Miss_7m': 'üß± Fehlwurf (7m)', 
            'TechError': 'üö´ Technischer Fehler', 'Fehlpass': 'üö´ Fehlpass', 
            'Save': 'üõë Parade', 'SEVEN_METER_CAUSED': 'üö® 7m verursacht',
            'SEVEN_METER_SAVE': 'üß± 7m Gehalten', 'SEVEN_METER_RECEIVED': 'üü° 7m Bekommen', 
            'OppGoal': 'üü° Gegner Tor', 'OppMiss': 'üí® Gegner Fehlwurf',
            'OppTechError': 'üö´ Gegner Tech. Fehler'
        };

        filteredActions.forEach(a => {
            const videoUrlJs = a.game_video_url ? `'${a.game_video_url.replace(/'/g, "\\'")}'` : "null";
            const opponentJs = `'${a.game_opponent.replace(/'/g, "\\'")}'`;
            const actionText = actionTextMap[a.action_type] || a.action_type;
            const playerText = a.player_name ? `(${a.player_name})` : '';
            
            const item = document.createElement('div');
            item.className = 'playlist-item';
            // KORREKTUR: "item" (das Element selbst) als erstes Argument √ºbergeben
            item.onclick = () => playScene(item, videoUrlJs, a.video_timestamp, opponentJs);
            item.innerHTML = `
                <span class="time">${formatVideoTime(a.video_timestamp)}</span>
                <span>${actionText} ${playerText}</span>
                <span class="opponent">vs. ${a.game_opponent}</span>
            `;
            cutterPlaylistContainer.appendChild(item);
        });
    }

    // 7. KORRIGIERTE Szene-Abspielfunktion
    function playScene(element, gameVideoUrl, timestamp, opponentName) {
        if (!cutterPlayerReady) {
            showToast("Video-API ist noch nicht bereit. Moment...", "error");
            return;
        }
        if (!gameVideoUrl || gameVideoUrl === 'null') {
            showToast("F√ºr dieses Spiel wurde keine Video-URL hinterlegt.", "error");
            return;
        }

        // Highlight
        if (activePlaylistItem) {
            activePlaylistItem.classList.remove('active');
        }
        element.classList.add('active');
        activePlaylistItem = element;
        
        cutterVideoTitle.textContent = `Spiel: vs. ${opponentName}`;
        const videoId = extractVideoID(gameVideoUrl);
        const timeInSeconds = parseFloat(timestamp);

        if (!videoId) {
            showToast("Ung√ºltige Video-URL f√ºr diese Aktion.", "error");
            return;
        }

        if (cutterPlayer === null) {
            // ===============================================
            // FALL 1: Player existiert nicht. Erstelle ihn JETZT.
            // ===============================================
            console.log(`Erstelle Player mit Video-ID: ${videoId}`);
            lastLoadedVideoId = videoId;
            cutterPlayer = new YT.Player('cutter-youtube-player', {
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: { 
                    'playsinline': 1, 
                    'modestbranding': 1, 
                    'rel': 0,
                    'start': Math.floor(timeInSeconds) // Starte direkt an der Zeit
                },
                events: {
                    'onReady': (event) => { event.target.playVideo(); }
                }
            });
        
        } else if (videoId === lastLoadedVideoId) {
            // ===============================================
            // FALL 2: Player existiert, Video ist das GLEICHE.
            // ===============================================
            console.log(`Video ist gleich. Springe zu: ${timeInSeconds}`);
            cutterPlayer.seekTo(timeInSeconds, true);
            cutterPlayer.playVideo();
        
        } else {
            // ===============================================
            // FALL 3: Player existiert, Video ist NEU.
            // ===============================================
            console.log(`Lade neues Video: ${videoId}`);
            lastLoadedVideoId = videoId;
            // Lade das neue Video und starte es an der Zeit
            cutterPlayer.loadVideoById({
                videoId: videoId,
                startSeconds: Math.floor(timeInSeconds)
            });
            // YouTube API spielt nach loadVideoById oft automatisch ab,
            // wenn es in einem Event-Handler passiert.
        }
    }
    
    // 8. KORRIGIERTE Hilfsfunktion (kopiert aus protocol.html)
    function formatVideoTime(seconds) {
        // KORRIGIERT: Erlaube "0.00" als g√ºltigen Zeitstempel "00:00"
        if (seconds === null || seconds === undefined) return '‚Äî';
        
        const totalSec = Math.floor(parseFloat(seconds));
        
        if (isNaN(totalSec) || totalSec < 0) return '‚Äî';
        
        try {
            const min = Math.floor(totalSec / 60);
            const sec = totalSec % 60;
            return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        } catch (e) {
            return 'N/A';
        }
    }

    // ==================================================
    // ENDE KORRIGIERTE JS-FUNKTIONEN
    // ==================================================


    // --- Initialisierung ---
    function initSeasonAnalysis() {
        console.log("initSeasonAnalysis() wird aufgerufen.");
        const storedId = localStorage.getItem('selected_team_id');
        const storedName = localStorage.getItem('selected_team_name');
        
        if (storedId && storedName) {
            selectedTeamId = storedId;
            selectedTeamName = storedName;
            seasonStatsTeamName.textContent = selectedTeamName;
            loadSeasonStatsBtn.disabled = false;
            archiveSeasonBtn.disabled = false;
            
            // Lade ALLE Daten f√ºr diese Seite
            loadSeasonStats(); // L√§dt Statistiken UND Wurfbilder
            
            // NEU (PHASE 8): Lade Video-API und Playlist-Daten
            loadYouTubeAPI();
            loadSeasonActionData(); 
            
        } else {
            seasonStatsTeamName.textContent = "(Team w√§hlen)";
            loadSeasonStatsBtn.disabled = true;
            archiveSeasonBtn.disabled = true;
            shotChartPlayerSelect.innerHTML = '<option value="" disabled selected>Team w√§hlen...</option>';
            shotChartOverlay.innerHTML = '';
            errorChartPlayerSelect.innerHTML = '<option value="" disabled selected>Team w√§hlen...</option>';
            errorChartOverlay.innerHTML = '';
            if (opponentShotChartOverlay) { opponentShotChartOverlay.innerHTML = ''; }
            // NEU: Playlist leeren
            cutterPlaylistContainer.innerHTML = '<p style="opacity: 0.6; text-align: center; padding: 20px;">Bitte zuerst ein Team ausw√§hlen.</p>';
        }
    }
    
    // Ruft die init-Funktion dieser Seite auf
    initSeasonAnalysis();
</script>